// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	context "context"

	aws "github.com/aws/aws-sdk-go/aws"
	codebuild "github.com/aws/aws-sdk-go/service/codebuild"

	mock "github.com/stretchr/testify/mock"

	request "github.com/aws/aws-sdk-go/aws/request"
)

// CodeBuildAPI is an autogenerated mock type for the CodeBuildAPI type
type CodeBuildAPI struct {
	mock.Mock
}

// BatchDeleteBuilds provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchDeleteBuilds(_a0 *codebuild.BatchDeleteBuildsInput) (*codebuild.BatchDeleteBuildsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.BatchDeleteBuildsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.BatchDeleteBuildsInput) *codebuild.BatchDeleteBuildsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchDeleteBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.BatchDeleteBuildsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchDeleteBuildsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchDeleteBuildsRequest(_a0 *codebuild.BatchDeleteBuildsInput) (*request.Request, *codebuild.BatchDeleteBuildsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.BatchDeleteBuildsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.BatchDeleteBuildsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.BatchDeleteBuildsInput) *codebuild.BatchDeleteBuildsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.BatchDeleteBuildsOutput)
		}
	}

	return r0, r1
}

// BatchDeleteBuildsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) BatchDeleteBuildsWithContext(_a0 context.Context, _a1 *codebuild.BatchDeleteBuildsInput, _a2 ...request.Option) (*codebuild.BatchDeleteBuildsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.BatchDeleteBuildsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchDeleteBuildsInput, ...request.Option) *codebuild.BatchDeleteBuildsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchDeleteBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchDeleteBuildsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetBuilds provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchGetBuilds(_a0 *codebuild.BatchGetBuildsInput) (*codebuild.BatchGetBuildsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.BatchGetBuildsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.BatchGetBuildsInput) *codebuild.BatchGetBuildsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.BatchGetBuildsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetBuildsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchGetBuildsRequest(_a0 *codebuild.BatchGetBuildsInput) (*request.Request, *codebuild.BatchGetBuildsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.BatchGetBuildsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.BatchGetBuildsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.BatchGetBuildsInput) *codebuild.BatchGetBuildsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.BatchGetBuildsOutput)
		}
	}

	return r0, r1
}

// BatchGetBuildsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) BatchGetBuildsWithContext(_a0 context.Context, _a1 *codebuild.BatchGetBuildsInput, _a2 ...request.Option) (*codebuild.BatchGetBuildsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.BatchGetBuildsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetBuildsInput, ...request.Option) *codebuild.BatchGetBuildsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetBuildsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetProjects provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchGetProjects(_a0 *codebuild.BatchGetProjectsInput) (*codebuild.BatchGetProjectsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.BatchGetProjectsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.BatchGetProjectsInput) *codebuild.BatchGetProjectsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetProjectsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.BatchGetProjectsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchGetProjectsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) BatchGetProjectsRequest(_a0 *codebuild.BatchGetProjectsInput) (*request.Request, *codebuild.BatchGetProjectsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.BatchGetProjectsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.BatchGetProjectsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.BatchGetProjectsInput) *codebuild.BatchGetProjectsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.BatchGetProjectsOutput)
		}
	}

	return r0, r1
}

// BatchGetProjectsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) BatchGetProjectsWithContext(_a0 context.Context, _a1 *codebuild.BatchGetProjectsInput, _a2 ...request.Option) (*codebuild.BatchGetProjectsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.BatchGetProjectsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.BatchGetProjectsInput, ...request.Option) *codebuild.BatchGetProjectsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.BatchGetProjectsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.BatchGetProjectsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) CreateProject(_a0 *codebuild.CreateProjectInput) (*codebuild.CreateProjectOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.CreateProjectOutput
	if rf, ok := ret.Get(0).(func(*codebuild.CreateProjectInput) *codebuild.CreateProjectOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.CreateProjectInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProjectRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) CreateProjectRequest(_a0 *codebuild.CreateProjectInput) (*request.Request, *codebuild.CreateProjectOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.CreateProjectInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.CreateProjectOutput
	if rf, ok := ret.Get(1).(func(*codebuild.CreateProjectInput) *codebuild.CreateProjectOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.CreateProjectOutput)
		}
	}

	return r0, r1
}

// CreateProjectWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) CreateProjectWithContext(_a0 context.Context, _a1 *codebuild.CreateProjectInput, _a2 ...request.Option) (*codebuild.CreateProjectOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.CreateProjectOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateProjectInput, ...request.Option) *codebuild.CreateProjectOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateProjectInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebhook provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) CreateWebhook(_a0 *codebuild.CreateWebhookInput) (*codebuild.CreateWebhookOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.CreateWebhookOutput
	if rf, ok := ret.Get(0).(func(*codebuild.CreateWebhookInput) *codebuild.CreateWebhookOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.CreateWebhookInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWebhookRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) CreateWebhookRequest(_a0 *codebuild.CreateWebhookInput) (*request.Request, *codebuild.CreateWebhookOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.CreateWebhookInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.CreateWebhookOutput
	if rf, ok := ret.Get(1).(func(*codebuild.CreateWebhookInput) *codebuild.CreateWebhookOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.CreateWebhookOutput)
		}
	}

	return r0, r1
}

// CreateWebhookWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) CreateWebhookWithContext(_a0 context.Context, _a1 *codebuild.CreateWebhookInput, _a2 ...request.Option) (*codebuild.CreateWebhookOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.CreateWebhookOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.CreateWebhookInput, ...request.Option) *codebuild.CreateWebhookOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.CreateWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.CreateWebhookInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteProject(_a0 *codebuild.DeleteProjectInput) (*codebuild.DeleteProjectOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.DeleteProjectOutput
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteProjectInput) *codebuild.DeleteProjectOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteProjectInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProjectRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteProjectRequest(_a0 *codebuild.DeleteProjectInput) (*request.Request, *codebuild.DeleteProjectOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteProjectInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.DeleteProjectOutput
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteProjectInput) *codebuild.DeleteProjectOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.DeleteProjectOutput)
		}
	}

	return r0, r1
}

// DeleteProjectWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) DeleteProjectWithContext(_a0 context.Context, _a1 *codebuild.DeleteProjectInput, _a2 ...request.Option) (*codebuild.DeleteProjectOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.DeleteProjectOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteProjectInput, ...request.Option) *codebuild.DeleteProjectOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteProjectInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSourceCredentials provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteSourceCredentials(_a0 *codebuild.DeleteSourceCredentialsInput) (*codebuild.DeleteSourceCredentialsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.DeleteSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteSourceCredentialsInput) *codebuild.DeleteSourceCredentialsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteSourceCredentialsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSourceCredentialsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteSourceCredentialsRequest(_a0 *codebuild.DeleteSourceCredentialsInput) (*request.Request, *codebuild.DeleteSourceCredentialsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteSourceCredentialsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.DeleteSourceCredentialsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteSourceCredentialsInput) *codebuild.DeleteSourceCredentialsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.DeleteSourceCredentialsOutput)
		}
	}

	return r0, r1
}

// DeleteSourceCredentialsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) DeleteSourceCredentialsWithContext(_a0 context.Context, _a1 *codebuild.DeleteSourceCredentialsInput, _a2 ...request.Option) (*codebuild.DeleteSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.DeleteSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteSourceCredentialsInput, ...request.Option) *codebuild.DeleteSourceCredentialsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteSourceCredentialsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebhook provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteWebhook(_a0 *codebuild.DeleteWebhookInput) (*codebuild.DeleteWebhookOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.DeleteWebhookOutput
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteWebhookInput) *codebuild.DeleteWebhookOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteWebhookInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteWebhookRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) DeleteWebhookRequest(_a0 *codebuild.DeleteWebhookInput) (*request.Request, *codebuild.DeleteWebhookOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.DeleteWebhookInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.DeleteWebhookOutput
	if rf, ok := ret.Get(1).(func(*codebuild.DeleteWebhookInput) *codebuild.DeleteWebhookOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.DeleteWebhookOutput)
		}
	}

	return r0, r1
}

// DeleteWebhookWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) DeleteWebhookWithContext(_a0 context.Context, _a1 *codebuild.DeleteWebhookInput, _a2 ...request.Option) (*codebuild.DeleteWebhookOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.DeleteWebhookOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.DeleteWebhookInput, ...request.Option) *codebuild.DeleteWebhookOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.DeleteWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.DeleteWebhookInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSourceCredentials provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ImportSourceCredentials(_a0 *codebuild.ImportSourceCredentialsInput) (*codebuild.ImportSourceCredentialsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ImportSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ImportSourceCredentialsInput) *codebuild.ImportSourceCredentialsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ImportSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ImportSourceCredentialsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImportSourceCredentialsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ImportSourceCredentialsRequest(_a0 *codebuild.ImportSourceCredentialsInput) (*request.Request, *codebuild.ImportSourceCredentialsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ImportSourceCredentialsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ImportSourceCredentialsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ImportSourceCredentialsInput) *codebuild.ImportSourceCredentialsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ImportSourceCredentialsOutput)
		}
	}

	return r0, r1
}

// ImportSourceCredentialsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ImportSourceCredentialsWithContext(_a0 context.Context, _a1 *codebuild.ImportSourceCredentialsInput, _a2 ...request.Option) (*codebuild.ImportSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ImportSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ImportSourceCredentialsInput, ...request.Option) *codebuild.ImportSourceCredentialsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ImportSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ImportSourceCredentialsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvalidateProjectCache provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) InvalidateProjectCache(_a0 *codebuild.InvalidateProjectCacheInput) (*codebuild.InvalidateProjectCacheOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.InvalidateProjectCacheOutput
	if rf, ok := ret.Get(0).(func(*codebuild.InvalidateProjectCacheInput) *codebuild.InvalidateProjectCacheOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.InvalidateProjectCacheOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.InvalidateProjectCacheInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InvalidateProjectCacheRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) InvalidateProjectCacheRequest(_a0 *codebuild.InvalidateProjectCacheInput) (*request.Request, *codebuild.InvalidateProjectCacheOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.InvalidateProjectCacheInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.InvalidateProjectCacheOutput
	if rf, ok := ret.Get(1).(func(*codebuild.InvalidateProjectCacheInput) *codebuild.InvalidateProjectCacheOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.InvalidateProjectCacheOutput)
		}
	}

	return r0, r1
}

// InvalidateProjectCacheWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) InvalidateProjectCacheWithContext(_a0 context.Context, _a1 *codebuild.InvalidateProjectCacheInput, _a2 ...request.Option) (*codebuild.InvalidateProjectCacheOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.InvalidateProjectCacheOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.InvalidateProjectCacheInput, ...request.Option) *codebuild.InvalidateProjectCacheOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.InvalidateProjectCacheOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.InvalidateProjectCacheInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuilds provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListBuilds(_a0 *codebuild.ListBuildsInput) (*codebuild.ListBuildsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ListBuildsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ListBuildsInput) *codebuild.ListBuildsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ListBuildsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildsForProject provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListBuildsForProject(_a0 *codebuild.ListBuildsForProjectInput) (*codebuild.ListBuildsForProjectOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ListBuildsForProjectOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ListBuildsForProjectInput) *codebuild.ListBuildsForProjectOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsForProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ListBuildsForProjectInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildsForProjectRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListBuildsForProjectRequest(_a0 *codebuild.ListBuildsForProjectInput) (*request.Request, *codebuild.ListBuildsForProjectOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ListBuildsForProjectInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ListBuildsForProjectOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ListBuildsForProjectInput) *codebuild.ListBuildsForProjectOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ListBuildsForProjectOutput)
		}
	}

	return r0, r1
}

// ListBuildsForProjectWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ListBuildsForProjectWithContext(_a0 context.Context, _a1 *codebuild.ListBuildsForProjectInput, _a2 ...request.Option) (*codebuild.ListBuildsForProjectOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ListBuildsForProjectOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsForProjectInput, ...request.Option) *codebuild.ListBuildsForProjectOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsForProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildsForProjectInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuildsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListBuildsRequest(_a0 *codebuild.ListBuildsInput) (*request.Request, *codebuild.ListBuildsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ListBuildsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ListBuildsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ListBuildsInput) *codebuild.ListBuildsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ListBuildsOutput)
		}
	}

	return r0, r1
}

// ListBuildsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ListBuildsWithContext(_a0 context.Context, _a1 *codebuild.ListBuildsInput, _a2 ...request.Option) (*codebuild.ListBuildsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ListBuildsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListBuildsInput, ...request.Option) *codebuild.ListBuildsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListBuildsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListBuildsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCuratedEnvironmentImages provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListCuratedEnvironmentImages(_a0 *codebuild.ListCuratedEnvironmentImagesInput) (*codebuild.ListCuratedEnvironmentImagesOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ListCuratedEnvironmentImagesOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ListCuratedEnvironmentImagesInput) *codebuild.ListCuratedEnvironmentImagesOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListCuratedEnvironmentImagesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ListCuratedEnvironmentImagesInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCuratedEnvironmentImagesRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListCuratedEnvironmentImagesRequest(_a0 *codebuild.ListCuratedEnvironmentImagesInput) (*request.Request, *codebuild.ListCuratedEnvironmentImagesOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ListCuratedEnvironmentImagesInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ListCuratedEnvironmentImagesOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ListCuratedEnvironmentImagesInput) *codebuild.ListCuratedEnvironmentImagesOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ListCuratedEnvironmentImagesOutput)
		}
	}

	return r0, r1
}

// ListCuratedEnvironmentImagesWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ListCuratedEnvironmentImagesWithContext(_a0 context.Context, _a1 *codebuild.ListCuratedEnvironmentImagesInput, _a2 ...request.Option) (*codebuild.ListCuratedEnvironmentImagesOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ListCuratedEnvironmentImagesOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListCuratedEnvironmentImagesInput, ...request.Option) *codebuild.ListCuratedEnvironmentImagesOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListCuratedEnvironmentImagesOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListCuratedEnvironmentImagesInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListProjects(_a0 *codebuild.ListProjectsInput) (*codebuild.ListProjectsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ListProjectsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ListProjectsInput) *codebuild.ListProjectsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListProjectsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ListProjectsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjectsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListProjectsRequest(_a0 *codebuild.ListProjectsInput) (*request.Request, *codebuild.ListProjectsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ListProjectsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ListProjectsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ListProjectsInput) *codebuild.ListProjectsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ListProjectsOutput)
		}
	}

	return r0, r1
}

// ListProjectsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ListProjectsWithContext(_a0 context.Context, _a1 *codebuild.ListProjectsInput, _a2 ...request.Option) (*codebuild.ListProjectsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ListProjectsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListProjectsInput, ...request.Option) *codebuild.ListProjectsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListProjectsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListProjectsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSourceCredentials provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListSourceCredentials(_a0 *codebuild.ListSourceCredentialsInput) (*codebuild.ListSourceCredentialsOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.ListSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(*codebuild.ListSourceCredentialsInput) *codebuild.ListSourceCredentialsOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.ListSourceCredentialsInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSourceCredentialsRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) ListSourceCredentialsRequest(_a0 *codebuild.ListSourceCredentialsInput) (*request.Request, *codebuild.ListSourceCredentialsOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.ListSourceCredentialsInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.ListSourceCredentialsOutput
	if rf, ok := ret.Get(1).(func(*codebuild.ListSourceCredentialsInput) *codebuild.ListSourceCredentialsOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.ListSourceCredentialsOutput)
		}
	}

	return r0, r1
}

// ListSourceCredentialsWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) ListSourceCredentialsWithContext(_a0 context.Context, _a1 *codebuild.ListSourceCredentialsInput, _a2 ...request.Option) (*codebuild.ListSourceCredentialsOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.ListSourceCredentialsOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.ListSourceCredentialsInput, ...request.Option) *codebuild.ListSourceCredentialsOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.ListSourceCredentialsOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.ListSourceCredentialsInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBuild provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) StartBuild(_a0 *codebuild.StartBuildInput) (*codebuild.StartBuildOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.StartBuildOutput
	if rf, ok := ret.Get(0).(func(*codebuild.StartBuildInput) *codebuild.StartBuildOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StartBuildOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.StartBuildInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StartBuildRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) StartBuildRequest(_a0 *codebuild.StartBuildInput) (*request.Request, *codebuild.StartBuildOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.StartBuildInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.StartBuildOutput
	if rf, ok := ret.Get(1).(func(*codebuild.StartBuildInput) *codebuild.StartBuildOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.StartBuildOutput)
		}
	}

	return r0, r1
}

// StartBuildWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) StartBuildWithContext(_a0 context.Context, _a1 *codebuild.StartBuildInput, _a2 ...request.Option) (*codebuild.StartBuildOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.StartBuildOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StartBuildInput, ...request.Option) *codebuild.StartBuildOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StartBuildOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StartBuildInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBuild provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) StopBuild(_a0 *codebuild.StopBuildInput) (*codebuild.StopBuildOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.StopBuildOutput
	if rf, ok := ret.Get(0).(func(*codebuild.StopBuildInput) *codebuild.StopBuildOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StopBuildOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.StopBuildInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopBuildRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) StopBuildRequest(_a0 *codebuild.StopBuildInput) (*request.Request, *codebuild.StopBuildOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.StopBuildInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.StopBuildOutput
	if rf, ok := ret.Get(1).(func(*codebuild.StopBuildInput) *codebuild.StopBuildOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.StopBuildOutput)
		}
	}

	return r0, r1
}

// StopBuildWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) StopBuildWithContext(_a0 context.Context, _a1 *codebuild.StopBuildInput, _a2 ...request.Option) (*codebuild.StopBuildOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.StopBuildOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.StopBuildInput, ...request.Option) *codebuild.StopBuildOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.StopBuildOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.StopBuildInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProject provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) UpdateProject(_a0 *codebuild.UpdateProjectInput) (*codebuild.UpdateProjectOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.UpdateProjectOutput
	if rf, ok := ret.Get(0).(func(*codebuild.UpdateProjectInput) *codebuild.UpdateProjectOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.UpdateProjectInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProjectRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) UpdateProjectRequest(_a0 *codebuild.UpdateProjectInput) (*request.Request, *codebuild.UpdateProjectOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.UpdateProjectInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.UpdateProjectOutput
	if rf, ok := ret.Get(1).(func(*codebuild.UpdateProjectInput) *codebuild.UpdateProjectOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.UpdateProjectOutput)
		}
	}

	return r0, r1
}

// UpdateProjectWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) UpdateProjectWithContext(_a0 context.Context, _a1 *codebuild.UpdateProjectInput, _a2 ...request.Option) (*codebuild.UpdateProjectOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.UpdateProjectOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateProjectInput, ...request.Option) *codebuild.UpdateProjectOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateProjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateProjectInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebhook provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) UpdateWebhook(_a0 *codebuild.UpdateWebhookInput) (*codebuild.UpdateWebhookOutput, error) {
	ret := _m.Called(_a0)

	var r0 *codebuild.UpdateWebhookOutput
	if rf, ok := ret.Get(0).(func(*codebuild.UpdateWebhookInput) *codebuild.UpdateWebhookOutput); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*codebuild.UpdateWebhookInput) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateWebhookRequest provides a mock function with given fields: _a0
func (_m *CodeBuildAPI) UpdateWebhookRequest(_a0 *codebuild.UpdateWebhookInput) (*request.Request, *codebuild.UpdateWebhookOutput) {
	ret := _m.Called(_a0)

	var r0 *request.Request
	if rf, ok := ret.Get(0).(func(*codebuild.UpdateWebhookInput) *request.Request); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*request.Request)
		}
	}

	var r1 *codebuild.UpdateWebhookOutput
	if rf, ok := ret.Get(1).(func(*codebuild.UpdateWebhookInput) *codebuild.UpdateWebhookOutput); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*codebuild.UpdateWebhookOutput)
		}
	}

	return r0, r1
}

// UpdateWebhookWithContext provides a mock function with given fields: _a0, _a1, _a2
func (_m *CodeBuildAPI) UpdateWebhookWithContext(_a0 context.Context, _a1 *codebuild.UpdateWebhookInput, _a2 ...request.Option) (*codebuild.UpdateWebhookOutput, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *codebuild.UpdateWebhookOutput
	if rf, ok := ret.Get(0).(func(context.Context, *codebuild.UpdateWebhookInput, ...request.Option) *codebuild.UpdateWebhookOutput); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*codebuild.UpdateWebhookOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *codebuild.UpdateWebhookInput, ...request.Option) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

func (_m *CodeBuildAPI) BatchGetBuildBatches(input *codebuild.BatchGetBuildBatchesInput) (*codebuild.BatchGetBuildBatchesOutput, error) {
	panic("CodeBuildAPI::BatchGetBuildBatches - Not implemented")
}

func (_m *CodeBuildAPI) BatchGetBuildBatchesRequest(input *codebuild.BatchGetBuildBatchesInput) (req *request.Request, output *codebuild.BatchGetBuildBatchesOutput) {
	panic("CodeBuildAPI::BatchGetBuildBatchesRequest - Not implemented")
}

func (_m *CodeBuildAPI) BatchGetBuildBatchesWithContext(ctx aws.Context, input *codebuild.BatchGetBuildBatchesInput, opts ...request.Option) (*codebuild.BatchGetBuildBatchesOutput, error) {
	panic("CodeBuildAPI::BatchGetBuildBatchesWithContext - Not implemented")
}

func (_m *CodeBuildAPI) BatchGetReportGroups(input *codebuild.BatchGetReportGroupsInput) (*codebuild.BatchGetReportGroupsOutput, error) {
	panic("CodeBuildAPI::BatchGetReportGroups - Not implemented")
}
func (_m *CodeBuildAPI) BatchGetReportGroupsRequest(input *codebuild.BatchGetReportGroupsInput) (req *request.Request, output *codebuild.BatchGetReportGroupsOutput) {
	panic("CodeBuildAPI::BatchGetReportGroupsRequest - Not implemented")
}
func (_m *CodeBuildAPI) BatchGetReportGroupsWithContext(ctx aws.Context, input *codebuild.BatchGetReportGroupsInput, opts ...request.Option) (*codebuild.BatchGetReportGroupsOutput, error) {
	panic("CodeBuildAPI::BatchGetReportGroupsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) BatchGetReports(input *codebuild.BatchGetReportsInput) (*codebuild.BatchGetReportsOutput, error) {
	panic("CodeBuildAPI::BatchGetReports - Not implemented")
}
func (_m *CodeBuildAPI) BatchGetReportsRequest(input *codebuild.BatchGetReportsInput) (req *request.Request, output *codebuild.BatchGetReportsOutput) {
	panic("CodeBuildAPI::BatchGetReportsRequest - Not implemented")
}
func (_m *CodeBuildAPI) BatchGetReportsWithContext(ctx aws.Context, input *codebuild.BatchGetReportsInput, opts ...request.Option) (*codebuild.BatchGetReportsOutput, error) {
	panic("CodeBuildAPI::BatchGetReportsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) CreateReportGroup(input *codebuild.CreateReportGroupInput) (*codebuild.CreateReportGroupOutput, error) {
	panic("CodeBuildAPI::CreateReportGroup - Not implemented")
}
func (_m *CodeBuildAPI) CreateReportGroupRequest(input *codebuild.CreateReportGroupInput) (req *request.Request, output *codebuild.CreateReportGroupOutput) {
	panic("CodeBuildAPI::CreateReportGroupRequest - Not implemented")
}
func (_m *CodeBuildAPI) CreateReportGroupWithContext(ctx aws.Context, input *codebuild.CreateReportGroupInput, opts ...request.Option) (*codebuild.CreateReportGroupOutput, error) {
	panic("CodeBuildAPI::CreateReportGroupWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DeleteBuildBatch(input *codebuild.DeleteBuildBatchInput) (*codebuild.DeleteBuildBatchOutput, error) {
	panic("CodeBuildAPI::DeleteBuildBatch - Not implemented")
}
func (_m *CodeBuildAPI) DeleteBuildBatchRequest(input *codebuild.DeleteBuildBatchInput) (req *request.Request, output *codebuild.DeleteBuildBatchOutput) {
	panic("CodeBuildAPI::DeleteBuildBatchRequest - Not implemented")
}
func (_m *CodeBuildAPI) DeleteBuildBatchWithContext(ctx aws.Context, input *codebuild.DeleteBuildBatchInput, opts ...request.Option) (*codebuild.DeleteBuildBatchOutput, error) {
	panic("CodeBuildAPI::DeleteBuildBatchWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReport(input *codebuild.DeleteReportInput) (*codebuild.DeleteReportOutput, error) {
	panic("CodeBuildAPI::DeleteReport - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReportRequest(input *codebuild.DeleteReportInput) (req *request.Request, output *codebuild.DeleteReportOutput) {
	panic("CodeBuildAPI::DeleteReportRequest - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReportWithContext(ctx aws.Context, input *codebuild.DeleteReportInput, opts ...request.Option) (*codebuild.DeleteReportOutput, error) {
	panic("CodeBuildAPI::DeleteReportWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReportGroup(input *codebuild.DeleteReportGroupInput) (*codebuild.DeleteReportGroupOutput, error) {
	panic("CodeBuildAPI::DeleteReportGroup - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReportGroupRequest(input *codebuild.DeleteReportGroupInput) (req *request.Request, output *codebuild.DeleteReportGroupOutput) {
	panic("CodeBuildAPI::DeleteReportGroupRequest - Not implemented")
}
func (_m *CodeBuildAPI) DeleteReportGroupWithContext(ctx aws.Context, input *codebuild.DeleteReportGroupInput, opts ...request.Option) (*codebuild.DeleteReportGroupOutput, error) {
	panic("CodeBuildAPI::DeleteReportGroupWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DeleteResourcePolicy(input *codebuild.DeleteResourcePolicyInput) (*codebuild.DeleteResourcePolicyOutput, error) {
	panic("CodeBuildAPI::DeleteResourcePolicy - Not implemented")
}
func (_m *CodeBuildAPI) DeleteResourcePolicyRequest(input *codebuild.DeleteResourcePolicyInput) (req *request.Request, output *codebuild.DeleteResourcePolicyOutput) {
	panic("CodeBuildAPI::DeleteResourcePolicyRequest - Not implemented")
}
func (_m *CodeBuildAPI) DeleteResourcePolicyWithContext(ctx aws.Context, input *codebuild.DeleteResourcePolicyInput, opts ...request.Option) (*codebuild.DeleteResourcePolicyOutput, error) {
	panic("CodeBuildAPI::DeleteResourcePolicyWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DescribeCodeCoverages(input *codebuild.DescribeCodeCoveragesInput) (*codebuild.DescribeCodeCoveragesOutput, error) {
	panic("CodeBuildAPI::DescribeCodeCoverages - Not implemented")
}
func (_m *CodeBuildAPI) DescribeCodeCoveragesPages(input *codebuild.DescribeCodeCoveragesInput, fn func(*codebuild.DescribeCodeCoveragesOutput, bool) bool) error {
	panic("CodeBuildAPI::DescribeCodeCoveragesPages - Not implemented")
}
func (_m *CodeBuildAPI) DescribeCodeCoveragesPagesWithContext(ctx aws.Context, input *codebuild.DescribeCodeCoveragesInput, fn func(*codebuild.DescribeCodeCoveragesOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::DescribeCodeCoveragesPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DescribeCodeCoveragesRequest(input *codebuild.DescribeCodeCoveragesInput) (req *request.Request, output *codebuild.DescribeCodeCoveragesOutput) {
	panic("CodeBuildAPI::DescribeCodeCoveragesRequest - Not implemented")
}
func (_m *CodeBuildAPI) DescribeCodeCoveragesWithContext(ctx aws.Context, input *codebuild.DescribeCodeCoveragesInput, opts ...request.Option) (*codebuild.DescribeCodeCoveragesOutput, error) {
	panic("CodeBuildAPI::DescribeCodeCoveragesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DescribeTestCases(input *codebuild.DescribeTestCasesInput) (*codebuild.DescribeTestCasesOutput, error) {
	panic("CodeBuildAPI::DescribeTestCases - Not implemented")
}
func (_m *CodeBuildAPI) DescribeTestCasesPages(input *codebuild.DescribeTestCasesInput, fn func(*codebuild.DescribeTestCasesOutput, bool) bool) error {
	panic("CodeBuildAPI::DescribeTestCasesPages - Not implemented")
}
func (_m *CodeBuildAPI) DescribeTestCasesPagesWithContext(ctx aws.Context, input *codebuild.DescribeTestCasesInput, fn func(*codebuild.DescribeTestCasesOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::DescribeTestCasesPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) DescribeTestCasesRequest(input *codebuild.DescribeTestCasesInput) (req *request.Request, output *codebuild.DescribeTestCasesOutput) {
	panic("CodeBuildAPI::DescribeTestCasesRequest - Not implemented")
}
func (_m *CodeBuildAPI) DescribeTestCasesWithContext(ctx aws.Context, input *codebuild.DescribeTestCasesInput, opts ...request.Option) (*codebuild.DescribeTestCasesOutput, error) {
	panic("CodeBuildAPI::DescribeTestCasesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) GetResourcePolicy(input *codebuild.GetResourcePolicyInput) (*codebuild.GetResourcePolicyOutput, error) {
	panic("CodeBuildAPI::GetResourcePolicy - Not implemented")
}
func (_m *CodeBuildAPI) GetResourcePolicyRequest(input *codebuild.GetResourcePolicyInput) (req *request.Request, output *codebuild.GetResourcePolicyOutput) {
	panic("CodeBuildAPI::GetResourcePolicyRequest - Not implemented")
}
func (_m *CodeBuildAPI) GetResourcePolicyWithContext(ctx aws.Context, input *codebuild.GetResourcePolicyInput, opts ...request.Option) (*codebuild.GetResourcePolicyOutput, error) {
	panic("CodeBuildAPI::GetResourcePolicyWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatches(input *codebuild.ListBuildBatchesInput) (*codebuild.ListBuildBatchesOutput, error) {
	panic("CodeBuildAPI::ListBuildBatches - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesForProject(input *codebuild.ListBuildBatchesForProjectInput) (*codebuild.ListBuildBatchesForProjectOutput, error) {
	panic("CodeBuildAPI::ListBuildBatchesForProject - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesForProjectPages(input *codebuild.ListBuildBatchesForProjectInput, fn func(*codebuild.ListBuildBatchesForProjectOutput, bool) bool) error {
	panic("CodeBuildAPI::ListBuildBatchesForProjectPages - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesForProjectPagesWithContext(ctx aws.Context, input *codebuild.ListBuildBatchesForProjectInput, fn func(*codebuild.ListBuildBatchesForProjectOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListBuildBatchesForProjectPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesForProjectRequest(input *codebuild.ListBuildBatchesForProjectInput) (req *request.Request, output *codebuild.ListBuildBatchesForProjectOutput) {
	panic("CodeBuildAPI::ListBuildBatchesForProjectRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesForProjectWithContext(ctx aws.Context, input *codebuild.ListBuildBatchesForProjectInput, opts ...request.Option) (*codebuild.ListBuildBatchesForProjectOutput, error) {
	panic("CodeBuildAPI::ListBuildBatchesForProjectWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesPages(input *codebuild.ListBuildBatchesInput, fn func(*codebuild.ListBuildBatchesOutput, bool) bool) error {
	panic("CodeBuildAPI::ListBuildBatchesPages - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesPagesWithContext(ctx aws.Context, input *codebuild.ListBuildBatchesInput, fn func(*codebuild.ListBuildBatchesOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListBuildBatchesPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesRequest(input *codebuild.ListBuildBatchesInput) (req *request.Request, output *codebuild.ListBuildBatchesOutput) {
	panic("CodeBuildAPI::ListBuildBatchesRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildBatchesWithContext(ctx aws.Context, input *codebuild.ListBuildBatchesInput, opts ...request.Option) (*codebuild.ListBuildBatchesOutput, error) {
	panic("CodeBuildAPI::ListBuildBatchesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildsForProjectPages(input *codebuild.ListBuildsForProjectInput, fn func(*codebuild.ListBuildsForProjectOutput, bool) bool) error {
	panic("CodeBuildAPI::ListBuildsForProjectPages - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildsForProjectPagesWithContext(ctx aws.Context, input *codebuild.ListBuildsForProjectInput, fn func(*codebuild.ListBuildsForProjectOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListBuildsForProjectPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildsPages(input *codebuild.ListBuildsInput, fn func(*codebuild.ListBuildsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListBuildsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListBuildsPagesWithContext(ctx aws.Context, input *codebuild.ListBuildsInput, fn func(*codebuild.ListBuildsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListBuildsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListProjectsPages(input *codebuild.ListProjectsInput, fn func(*codebuild.ListProjectsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListProjectsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListProjectsPagesWithContext(ctx aws.Context, input *codebuild.ListProjectsInput, fn func(*codebuild.ListProjectsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListProjectsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportGroups(input *codebuild.ListReportGroupsInput) (*codebuild.ListReportGroupsOutput, error) {
	panic("CodeBuildAPI::ListReportGroups - Not implemented")
}
func (_m *CodeBuildAPI) ListReportGroupsWithContext(ctx aws.Context, input *codebuild.ListReportGroupsInput, opts ...request.Option) (*codebuild.ListReportGroupsOutput, error) {
	panic("CodeBuildAPI::ListReportGroupsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportGroupsPages(input *codebuild.ListReportGroupsInput, fn func(*codebuild.ListReportGroupsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListReportGroupsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListReportGroupsPagesWithContext(ctx aws.Context, input *codebuild.ListReportGroupsInput, fn func(*codebuild.ListReportGroupsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListReportGroupsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportGroupsRequest(input *codebuild.ListReportGroupsInput) (req *request.Request, output *codebuild.ListReportGroupsOutput) {
	panic("CodeBuildAPI::ListReportGroupsRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListReports(input *codebuild.ListReportsInput) (*codebuild.ListReportsOutput, error) {
	panic("CodeBuildAPI::ListReports - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsForReportGroup(input *codebuild.ListReportsForReportGroupInput) (*codebuild.ListReportsForReportGroupOutput, error) {
	panic("CodeBuildAPI::ListReportsForReportGroup - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsForReportGroupPages(input *codebuild.ListReportsForReportGroupInput, fn func(*codebuild.ListReportsForReportGroupOutput, bool) bool) error {
	panic("CodeBuildAPI::ListReportsForReportGroupPages - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsForReportGroupPagesWithContext(ctx aws.Context, input *codebuild.ListReportsForReportGroupInput, fn func(*codebuild.ListReportsForReportGroupOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListReportsForReportGroupPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsForReportGroupRequest(input *codebuild.ListReportsForReportGroupInput) (req *request.Request, output *codebuild.ListReportsForReportGroupOutput) {
	panic("CodeBuildAPI::ListReportsForReportGroupRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsForReportGroupWithContext(ctx aws.Context, input *codebuild.ListReportsForReportGroupInput, opts ...request.Option) (*codebuild.ListReportsForReportGroupOutput, error) {
	panic("CodeBuildAPI::ListReportsForReportGroupWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsPages(input *codebuild.ListReportsInput, fn func(*codebuild.ListReportsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListReportsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsPagesWithContext(ctx aws.Context, input *codebuild.ListReportsInput, fn func(*codebuild.ListReportsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListReportsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsRequest(input *codebuild.ListReportsInput) (req *request.Request, output *codebuild.ListReportsOutput) {
	panic("CodeBuildAPI::ListReportsRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListReportsWithContext(ctx aws.Context, input *codebuild.ListReportsInput, opts ...request.Option) (*codebuild.ListReportsOutput, error) {
	panic("CodeBuildAPI::ListReportsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedProjects(input *codebuild.ListSharedProjectsInput) (*codebuild.ListSharedProjectsOutput, error) {
	panic("CodeBuildAPI::ListSharedProjects - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedProjectsPages(input *codebuild.ListSharedProjectsInput, fn func(*codebuild.ListSharedProjectsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListSharedProjectsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedProjectsPagesWithContext(ctx aws.Context, input *codebuild.ListSharedProjectsInput, fn func(*codebuild.ListSharedProjectsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListSharedProjectsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedProjectsRequest(input *codebuild.ListSharedProjectsInput) (req *request.Request, output *codebuild.ListSharedProjectsOutput) {
	panic("CodeBuildAPI::ListSharedProjectsRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedProjectsWithContext(ctx aws.Context, input *codebuild.ListSharedProjectsInput, opts ...request.Option) (*codebuild.ListSharedProjectsOutput, error) {
	panic("CodeBuildAPI::ListSharedProjectsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedReportGroups(input *codebuild.ListSharedReportGroupsInput) (*codebuild.ListSharedReportGroupsOutput, error) {
	panic("CodeBuildAPI::ListSharedReportGroups - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedReportGroupsPages(input *codebuild.ListSharedReportGroupsInput, fn func(*codebuild.ListSharedReportGroupsOutput, bool) bool) error {
	panic("CodeBuildAPI::ListSharedReportGroupsPages - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedReportGroupsPagesWithContext(ctx aws.Context, input *codebuild.ListSharedReportGroupsInput, fn func(*codebuild.ListSharedReportGroupsOutput, bool) bool, opts ...request.Option) error {
	panic("CodeBuildAPI::ListSharedReportGroupsPagesWithContext - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedReportGroupsRequest(input *codebuild.ListSharedReportGroupsInput) (req *request.Request, output *codebuild.ListSharedReportGroupsOutput) {
	panic("CodeBuildAPI::ListSharedReportGroupsRequest - Not implemented")
}
func (_m *CodeBuildAPI) ListSharedReportGroupsWithContext(ctx aws.Context, input *codebuild.ListSharedReportGroupsInput, opts ...request.Option) (*codebuild.ListSharedReportGroupsOutput, error) {
	panic("CodeBuildAPI::ListSharedReportGroupsWithContext - Not implemented")
}
func (_m *CodeBuildAPI) PutResourcePolicy(input *codebuild.PutResourcePolicyInput) (*codebuild.PutResourcePolicyOutput, error) {
	panic("CodeBuildAPI::PutResourcePolicy - Not implemented")
}
func (_m *CodeBuildAPI) PutResourcePolicyRequest(input *codebuild.PutResourcePolicyInput) (req *request.Request, output *codebuild.PutResourcePolicyOutput) {
	panic("CodeBuildAPI::PutResourcePolicyRequest - Not implemented")
}
func (_m *CodeBuildAPI) PutResourcePolicyWithContext(ctx aws.Context, input *codebuild.PutResourcePolicyInput, opts ...request.Option) (*codebuild.PutResourcePolicyOutput, error) {
	panic("CodeBuildAPI::PutResourcePolicyWithContext - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuild(input *codebuild.RetryBuildInput) (*codebuild.RetryBuildOutput, error) {
	panic("CodeBuildAPI::RetryBuild - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuildBatch(input *codebuild.RetryBuildBatchInput) (*codebuild.RetryBuildBatchOutput, error) {
	panic("CodeBuildAPI::RetryBuildBatch - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuildBatchRequest(input *codebuild.RetryBuildBatchInput) (req *request.Request, output *codebuild.RetryBuildBatchOutput) {
	panic("CodeBuildAPI::RetryBuildBatchRequest - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuildBatchWithContext(ctx aws.Context, input *codebuild.RetryBuildBatchInput, opts ...request.Option) (*codebuild.RetryBuildBatchOutput, error) {
	panic("CodeBuildAPI::RetryBuildBatchWithContext - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuildRequest(input *codebuild.RetryBuildInput) (req *request.Request, output *codebuild.RetryBuildOutput) {
	panic("CodeBuildAPI::RetryBuildRequest - Not implemented")
}
func (_m *CodeBuildAPI) RetryBuildWithContext(ctx aws.Context, input *codebuild.RetryBuildInput, opts ...request.Option) (*codebuild.RetryBuildOutput, error) {
	panic("CodeBuildAPI::RetryBuildWithContext - Not implemented")
}
func (_m *CodeBuildAPI) StartBuildBatch(input *codebuild.StartBuildBatchInput) (*codebuild.StartBuildBatchOutput, error) {
	panic("CodeBuildAPI::StartBuildBatch - Not implemented")
}
func (_m *CodeBuildAPI) StartBuildBatchRequest(input *codebuild.StartBuildBatchInput) (req *request.Request, output *codebuild.StartBuildBatchOutput) {
	panic("CodeBuildAPI::StartBuildBatchRequest - Not implemented")
}
func (_m *CodeBuildAPI) StartBuildBatchWithContext(ctx aws.Context, input *codebuild.StartBuildBatchInput, opts ...request.Option) (*codebuild.StartBuildBatchOutput, error) {
	panic("CodeBuildAPI::StartBuildBatchWithContext - Not implemented")
}
func (_m *CodeBuildAPI) StopBuildBatch(input *codebuild.StopBuildBatchInput) (*codebuild.StopBuildBatchOutput, error) {
	panic("CodeBuildAPI::StopBuildBatch - Not implemented")
}
func (_m *CodeBuildAPI) StopBuildBatchRequest(input *codebuild.StopBuildBatchInput) (req *request.Request, output *codebuild.StopBuildBatchOutput) {
	panic("CodeBuildAPI::StopBuildBatchRequest - Not implemented")
}
func (_m *CodeBuildAPI) StopBuildBatchWithContext(ctx aws.Context, input *codebuild.StopBuildBatchInput, opts ...request.Option) (*codebuild.StopBuildBatchOutput, error) {
	panic("CodeBuildAPI::StopBuildBatchWithContext - Not implemented")
}
func (_m *CodeBuildAPI) UpdateReportGroup(input *codebuild.UpdateReportGroupInput) (*codebuild.UpdateReportGroupOutput, error) {
	panic("CodeBuildAPI::UpdateReportGroup - Not implemented")
}
func (_m *CodeBuildAPI) UpdateReportGroupRequest(input *codebuild.UpdateReportGroupInput) (req *request.Request, output *codebuild.UpdateReportGroupOutput) {
	panic("CodeBuildAPI::UpdateReportGroupRequest - Not implemented")
}
func (_m *CodeBuildAPI) UpdateReportGroupWithContext(ctx aws.Context, input *codebuild.UpdateReportGroupInput, opts ...request.Option) (*codebuild.UpdateReportGroupOutput, error) {
	panic("CodeBuildAPI::UpdateReportGroupWithContext - Not implemented")
}
